# 菜单和API权限数据同步方案

## 问题概述

每次版本迭代后，需要将新的菜单、API和权限数据同步到测试和生产环境，涉及以下表：
- `sys_apis` - API表
- `sys_base_menus` - 菜单表
- `sys_authority_menus` - 菜单权限关联表
- `casbin_rule` - Casbin权限规则表

---

## 🎯 **方案一：使用内置版本管理系统（推荐）**

项目已内置版本管理系统，这是**最简单和推荐**的方案。

### 1.1 本地环境操作（导出版本数据）

**步骤1：在本地开发环境创建版本**

访问：`http://localhost:8888/系统工具/版本管理`

1. 点击"创建版本"
2. 填写版本信息：
   - 版本名称：如 `v2.8.6`
   - 版本号：如 `2.8.6`
   - 版本描述：本次迭代的功能描述
3. 选择需要导出的数据：
   - ✅ 勾选新增的菜单
   - ✅ 勾选新增的API
   - ✅ 可选：勾选字典等
4. 点击"确定"创建版本

**步骤2：下载版本JSON文件**

在版本列表中，找到刚创建的版本，点击"下载版本JSON"，保存为：
```
version-v2.8.6.json
```

### 1.2 测试/生产环境操作（导入版本数据）

**步骤1：上传版本JSON文件**

访问测试/生产环境的版本管理页面，点击"同步版本"，选择下载的JSON文件上传。

**步骤2：自动导入**

系统会自动：
- 检查并创建新菜单（如果不存在）
- 检查并创建新API（如果不存在）
- 保持现有数据不变

### 1.3 API接口方式（适合CI/CD）

```bash
# 1. 导出版本数据（本地环境）
curl -X POST http://localhost:8888/api/sysVersion/exportVersion \
  -H "x-token: YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "versionName": "v2.8.6",
    "versionCode": "2.8.6",
    "description": "新增GM管理功能",
    "menuIds": [1, 2, 3],  # 新增的菜单ID列表
    "apiIds": [100, 101, 102]  # 新增的API ID列表
  }'

# 2. 获取版本JSON（本地环境）
curl -X GET "http://localhost:8888/api/sysVersion/downloadVersionJson?id=版本ID" \
  -H "x-token: YOUR_TOKEN" \
  -o version-v2.8.6.json

# 3. 导入版本数据（测试/生产环境）
curl -X POST http://test-server:8888/api/sysVersion/importVersion \
  -H "x-token: YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d @version-v2.8.6.json
```

---

## 🛠️ **方案二：扩展初始化系统（自动化）**

适合需要自动化、可编程控制的场景。

### 2.1 创建版本化的初始化文件

在 `server/source/system/` 目录下创建版本化的初始化文件：

```go
// server/source/system/api_v2.8.6.go
package system

import (
    "context"
    sysModel "gmserver/model/system"
    "gmserver/service/system"
    "github.com/pkg/errors"
    "gorm.io/gorm"
)

const initOrderApiV286 = initOrderApi + 1

type initApiV286 struct{}

func init() {
    system.RegisterInit(initOrderApiV286, &initApiV286{})
}

func (i *initApiV286) InitializerName() string {
    return "sys_apis_v2.8.6"
}

func (i *initApiV286) MigrateTable(ctx context.Context) (context.Context, error) {
    return ctx, nil // API表已存在，不需要创建
}

func (i *initApiV286) TableCreated(ctx context.Context) bool {
    return true
}

func (i *initApiV286) InitializeData(ctx context.Context) (context.Context, error) {
    db, ok := ctx.Value("db").(*gorm.DB)
    if !ok {
        return ctx, system.ErrMissingDBContext
    }
    
    // 新增的API数据
    newApis := []sysModel.SysApi{
        {
            ApiGroup:    "GM管理",
            Method:      "POST",
            Path:        "/gm/user/getUserList",
            Description: "获取GM用户列表",
        },
        {
            ApiGroup:    "GM管理",
            Method:      "POST",
            Path:        "/gm/item/getItemList",
            Description: "获取资源流水列表",
        },
    }
    
    // 使用 FirstOrCreate 避免重复插入
    for _, api := range newApis {
        var existing sysModel.SysApi
        result := db.Where("path = ? AND method = ?", api.Path, api.Method).First(&existing)
        if errors.Is(result.Error, gorm.ErrRecordNotFound) {
            if err := db.Create(&api).Error; err != nil {
                return ctx, errors.Wrap(err, "创建新API失败: "+api.Path)
            }
        }
    }
    
    return ctx, nil
}

func (i *initApiV286) DataInserted(ctx context.Context) bool {
    db, ok := ctx.Value("db").(*gorm.DB)
    if !ok {
        return false
    }
    // 检查是否已存在（通过某个唯一的API路径判断）
    if errors.Is(db.Where("path = ?", "/gm/item/getItemList").
        First(&sysModel.SysApi{}).Error, gorm.ErrRecordNotFound) {
        return false
    }
    return true
}
```

### 2.2 创建菜单初始化文件

```go
// server/source/system/menu_v2.8.6.go
package system

import (
    "context"
    sysModel "gmserver/model/system"
    "gmserver/service/system"
    "github.com/pkg/errors"
    "gorm.io/gorm"
)

const initOrderMenuV286 = initOrderMenu + 1

type initMenuV286 struct{}

func init() {
    system.RegisterInit(initOrderMenuV286, &initMenuV286{})
}

func (i *initMenuV286) InitializerName() string {
    return "sys_menus_v2.8.6"
}

func (i *initMenuV286) MigrateTable(ctx context.Context) (context.Context, error) {
    return ctx, nil
}

func (i *initMenuV286) TableCreated(ctx context.Context) bool {
    return true
}

func (i *initMenuV286) InitializeData(ctx context.Context) (context.Context, error) {
    db, ok := ctx.Value("db").(*gorm.DB)
    if !ok {
        return ctx, system.ErrMissingDBContext
    }
    
    // 查找父菜单
    var parentMenu sysModel.SysBaseMenu
    if err := db.Where("name = ?", "superAdmin").First(&parentMenu).Error; err != nil {
        return ctx, errors.Wrap(err, "未找到父菜单")
    }
    
    // 新增的菜单
    newMenus := []sysModel.SysBaseMenu{
        {
            MenuLevel: 1,
            Hidden:    false,
            ParentId:   parentMenu.ID,
            Path:       "gm",
            Name:       "gm",
            Component:  "view/gm/index.vue",
            Sort:       10,
            Meta: Meta{
                Title: "GM管理",
                Icon:  "user-filled",
            },
        },
    }
    
    for _, menu := range newMenus {
        var existing sysModel.SysBaseMenu
        result := db.Where("path = ? AND name = ?", menu.Path, menu.Name).First(&existing)
        if errors.Is(result.Error, gorm.ErrRecordNotFound) {
            if err := db.Create(&menu).Error; err != nil {
                return ctx, errors.Wrap(err, "创建新菜单失败: "+menu.Path)
            }
        }
    }
    
    return ctx, nil
}

func (i *initMenuV286) DataInserted(ctx context.Context) bool {
    db, ok := ctx.Value("db").(*gorm.DB)
    if !ok {
        return false
    }
    if errors.Is(db.Where("path = ?", "gm").
        First(&sysModel.SysBaseMenu{}).Error, gorm.ErrRecordNotFound) {
        return false
    }
    return true
}
```

### 2.3 使用方式

**自动执行**（推荐）：
- 系统启动时会自动检查并执行初始化
- 如果数据已存在，会跳过（通过 `DataInserted` 判断）

**手动触发**（需要新增接口）：
可以在管理后台添加"执行数据同步"按钮，手动触发初始化。

---

## 📝 **方案三：SQL迁移脚本（传统方案）**

适合熟悉SQL的团队，可以精确控制每个变更。

### 3.1 创建版本化的SQL文件

```sql
-- migrations/v2.8.6/menu_and_api.sql
-- 版本: v2.8.6
-- 日期: 2024-11-10
-- 说明: 新增GM管理功能相关菜单和API

-- 1. 插入新API
INSERT INTO sys_apis (created_at, updated_at, path, description, api_group, method)
VALUES 
    (NOW(), NOW(), '/gm/user/getUserList', '获取GM用户列表', 'GM管理', 'POST'),
    (NOW(), NOW(), '/gm/item/getItemList', '获取资源流水列表', 'GM管理', 'POST')
ON DUPLICATE KEY UPDATE 
    description = VALUES(description),
    api_group = VALUES(api_group);

-- 2. 插入新菜单（假设父菜单ID为100）
INSERT INTO sys_base_menus (created_at, updated_at, menu_level, parent_id, path, name, component, sort, hidden, title, icon, keep_alive, default_menu, close_tab, transition_type)
VALUES 
    (NOW(), NOW(), 1, 100, 'gm', 'gm', 'view/gm/index.vue', 10, 0, 'GM管理', 'user-filled', 0, 0, 0, '')
ON DUPLICATE KEY UPDATE 
    component = VALUES(component),
    sort = VALUES(sort);

-- 3. 为超级管理员角色(888)分配新菜单权限
INSERT INTO sys_authority_menus (sys_authority_authority_id, sys_base_menu_id)
SELECT 888, id 
FROM sys_base_menus 
WHERE path = 'gm' 
AND NOT EXISTS (
    SELECT 1 FROM sys_authority_menus 
    WHERE sys_authority_authority_id = 888 
    AND sys_base_menu_id = sys_base_menus.id
);

-- 4. 插入Casbin规则（为超级管理员添加API权限）
INSERT INTO casbin_rule (ptype, v0, v1, v2)
SELECT 'p', '888', api.path, api.method
FROM sys_apis api
WHERE api.api_group = 'GM管理'
AND NOT EXISTS (
    SELECT 1 FROM casbin_rule 
    WHERE ptype = 'p' 
    AND v0 = '888' 
    AND v1 = api.path 
    AND v2 = api.method
);
```

### 3.2 执行SQL脚本

```bash
# MySQL
mysql -u username -p database_name < migrations/v2.8.6/menu_and_api.sql

# 或者使用mysql客户端
mysql -u username -p database_name
source migrations/v2.8.6/menu_and_api.sql
```

---

## 🔄 **方案四：增量同步脚本（自动化程度高）**

创建一个Go工具脚本，自动对比本地和生产环境的差异，只同步新增的数据。

### 4.1 创建同步工具

```go
// tools/sync_data/sync.go
package main

import (
    "flag"
    "fmt"
    "gmserver/global"
    "gmserver/initialize"
    "gmserver/model/system"
    "gorm.io/gorm"
)

func main() {
    var env = flag.String("env", "test", "目标环境: test|prod")
    flag.Parse()
    
    // 初始化数据库连接
    initialize.OtherInit()
    global.GVA_DB = initialize.Gorm()
    
    // 同步菜单
    if err := syncMenus(global.GVA_DB); err != nil {
        fmt.Printf("同步菜单失败: %v\n", err)
        return
    }
    
    // 同步API
    if err := syncApis(global.GVA_DB); err != nil {
        fmt.Printf("同步API失败: %v\n", err)
        return
    }
    
    // 同步权限
    if err := syncPermissions(global.GVA_DB); err != nil {
        fmt.Printf("同步权限失败: %v\n", err)
        return
    }
    
    fmt.Println("数据同步完成！")
}

func syncMenus(db *gorm.DB) error {
    // 从本地数据库读取新菜单
    var localMenus []system.SysBaseMenu
    // TODO: 从某个标记或时间戳获取新增菜单
    db.Where("created_at > ?", "2024-11-01").Find(&localMenus)
    
    // 插入到目标数据库
    for _, menu := range localMenus {
        var existing system.SysBaseMenu
        if err := db.Where("path = ? AND name = ?", menu.Path, menu.Name).
            First(&existing).Error; err == nil {
            continue // 已存在，跳过
        }
        
        if err := db.Create(&menu).Error; err != nil {
            return err
        }
    }
    return nil
}

func syncApis(db *gorm.DB) error {
    // 类似菜单同步逻辑
    return nil
}

func syncPermissions(db *gorm.DB) error {
    // 同步权限关联
    return nil
}
```

---

## 📋 **最佳实践建议**

### 推荐工作流程

1. **开发阶段**
   - 在本地开发环境添加新菜单和API
   - 测试权限配置是否正确

2. **版本发布前**
   - 使用方案一（版本管理）导出新版本数据
   - 或使用方案二创建版本化的初始化文件

3. **测试环境同步**
   - 先同步到测试环境
   - 验证功能是否正常
   - 检查权限是否正确分配

4. **生产环境同步**
   - 确认测试环境无误后
   - 在维护窗口期执行同步
   - 记录同步日志

### 选择建议

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| 小团队，快速迭代 | 方案一（版本管理） | 简单易用，无需编码 |
| 需要自动化CI/CD | 方案二（扩展初始化） | 可编程，可集成 |
| 复杂数据迁移 | 方案三（SQL脚本） | 精确控制，灵活性高 |
| 多环境频繁同步 | 方案四（增量同步） | 自动化，减少人为错误 |

---

## ⚠️ **注意事项**

1. **数据备份**：同步前务必备份数据库
2. **权限检查**：确保权限关联正确，避免权限漏洞
3. **ID冲突**：使用唯一标识（如path+name）判断是否存在，而非ID
4. **事务处理**：确保数据一致性，使用数据库事务
5. **回滚方案**：准备回滚脚本，以防同步失败

---

## 🔍 **故障排查**

### 问题1：菜单显示但无权限
- 检查 `sys_authority_menus` 表是否正确关联
- 检查用户角色是否正确分配

### 问题2：API未生效
- 检查 `casbin_rule` 表是否正确插入
- 检查API路径和方法是否匹配

### 问题3：菜单层级错误
- 检查 `parent_id` 是否正确
- 确认父菜单已存在

---

## 总结

**最佳推荐**：使用**方案一（版本管理系统）**，因为：
- ✅ 项目已内置，无需额外开发
- ✅ Web界面操作，简单易用
- ✅ 支持版本管理和回滚
- ✅ 可以导出JSON，便于版本控制

如果需要更高自动化程度，可以结合**方案二（扩展初始化系统）**，实现启动时自动同步。

